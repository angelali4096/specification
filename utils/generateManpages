#!/usr/bin/env python

# For getting the arguments directly from command line
import sys
import os
import string
import datetime
import argparse

# boldWordsC and boldWordsF are a set of the key words that will be bolded in the man page
boldWordsC = {"void", "int", "const", "size_t", "short", "ptrdiff_t", "long", "TYPE", 
			"shmem_global_exit(int"}
boldWordsF = {"INTEGER", "CALL", "POINTER", "LOGICAL", "INTEGER*4",
				"INTEGER*8", "REAL*4", "REAL*8", "CHARACTER"}
routineList = ["shmem_init", "shmem_n_pes", "shmem_my_pe", "shmem_finalize", "shmem_global_exit", 
				"shmem_pe_accessible", "shmem_addr_accessible", "shmem_ptr", "shmem_info_get_version",
				"shmem_info_get_name", "start_pes", "shmem_malloc", "shmem_calloc", "shpalloc",
				"shpclmove", "shpdealloc", "shmem_put", "shmem_p", "shmem_iput", "shmem_get",
				"shmem_g", "shmem_iget", "shmem_put_nbi", "shmem_get_nbi", "shmem_atomic_fetch",
				"shmem_atomic_set", "shmem_atomic_compare_swap", "shmem_atomic_swap", 
				"shmem_atomic_fetch_inc", "shmem_atomic_inc", "shmem_atomic_fetch_add",
				"shmem_atomic_add", "shmem_atomic_fetch_or", "shmem_atomic_or", 
				"shmem_atomic_fetch_xor", "shmem_atomic_xor", "shmem_barrier_all",
				"shmem_barrier", "shmem_broadcast", "shmem_collect", "shmem_reductions",
				"shmem_alltoall", "shmem_alltoalls", "shmem_wait", "shmem_test", "shmem_fence",
				"shmem_quiet", "shmem_lock", "shmem_cache"]


def writeTH(functionName):
	titleHeader = ".TH " + functionName.upper() + " 3 " \
					 + "" + " " \
					 + "\"Open Source Software Solutions, Inc.\"" + " " \
					 + "\"OpenSHEMEM Library Documentation\"" + "\n"
	return titleHeader

def generalReplacements(tex):
	tex = tex.replace("\openshmem{}", "OpenSHMEM")
	tex = tex.replace("\openshmem", "OpenSHMEM")
	tex = tex.replace("\\acp{PE}", "PEs")
	tex = tex.replace("\\ac{PE}", "PE")
	tex = tex.replace("\\ac{MPI}", "MPI")
	tex = tex.replace("\\acp{AMO}", "AMOs")
	tex = tex.replace("\\ac{AMO}", "AMO")
	tex = tex.replace("\\ac{API}", "API")
	tex = tex.replace("\\acp{RMA}", "RMAs")
	tex = tex.replace("\\ac{RMA}", "RMA")
	tex = tex.replace("\\CorCpp{}", " C/C++")
	tex = tex.replace("\\CorCpp", " C/C++")
	tex = tex.replace("\\Fortran{}", "Fortran")
	tex = tex.replace("\\Fortran", "Fortran")
	tex = tex.replace("\\Cstd", "C")
	tex = tex.replace("\\PUT{}", "PUT")
	tex = tex.replace("\\GET{}", "GET")
	tex = tex.replace("\\SIZE{}", "SIZE")
	tex = tex.replace("\\activeset.", "\n.IR \"Active set\" .\n")
	tex = tex.replace("\\activeset{}", "\\activeset")
	tex = tex.replace("\\activeset", "\n.I \"Active set\"\n")
	tex = tex.replace("\\activeset ", "\n.I \"Active set\"\n")
	tex = tex.replace("\\dest.", "\n.IR \"dest\" .\n")
	tex = tex.replace("\\source.", "\n.IR \"source\" .\n")
	tex = tex.replace("\\dest{}", "\n.I \"dest\"\n")
	tex = tex.replace("\\source{}", "\n.I \"source\"\n")
	tex = tex.replace("\\TYPE{}", "TYPE")
	tex = tex.replace("\\TYPENAME{}", "TYPENAME")
	return tex

def funcReplacements(tex):
	while (tex.find("\FUNC{") != -1):
		beg = tex.find("\FUNC{")
		brace = tex.find("}", beg)
		if(tex[brace + 1] == "."):
			tex = tex[:beg] + "\n.BR \"" + tex[beg+len("\FUNC{"):brace] \
								+  "\" .\n" + tex[brace+2:]
		else:
			if(tex[brace + 1] == " "):
				tex = tex[:beg] + "\n.B " + tex[beg+len("\FUNC{"):brace] \
								+ "\n" + tex[brace+2:]
			else:
				tex = tex[:beg] + "\n.B " + tex[beg+len("\FUNC{"):brace] \
								+ "\n" + tex[brace+1:]
	return tex

def varReplacements(tex, keyString):
	while (tex.find(keyString) != -1):
		beg = tex.find(keyString)
		sbrace = tex.find("{", beg)
		ebrace = tex.find("}", sbrace)
		innerText = tex[sbrace+1:ebrace]
		if keyString == "\VARTH{":
			innerText += "th"
		if (tex[ebrace + 1] != "."):
			tex = tex[:beg] + "\n.I " + innerText \
					    	+ "\n" + tex[ebrace+1:]
		else:
			tex = tex[:beg] + "\n.IR \"" + innerText \
					    	+ "\" .\n" + tex[ebrace+1:]
	return tex

def variableReplacements(tex):
	tex = varReplacements(tex, "\VAR{")
	tex = varReplacements(tex, "\VARTH{")
	return tex

def mBoxReplacements(tex):
	while (tex.find("|\mbox") != -1):
		beg = tex.find("|\mbox")
		sbrace = tex.find("{", beg)
		ebrace = tex.find("}", sbrace)
		ebar = tex.find("|", sbrace)
		tex = tex[:beg] + tex[sbrace+1:ebrace] \
					    + tex[ebar+1:]
	return tex

def boldReplacements(tex):
	while (tex.find("\\textbf{") != -1):
		beg = tex.find("\\textbf{")
		sbrace = tex.find("{", beg)
		ebrace = tex.find("}", sbrace)
		fnewline = tex.find("\\newline", ebrace)
		snewline = tex.find("\\newline", fnewline + 1)
		clean = tex[fnewline + len("\\newline"):snewline]
		clean = macroReplacements(clean)
		tex = tex[:beg] + "\n.SH " + tex[sbrace+1:ebrace] \
				    	+ "\n" + clean \
				    	+ tex[snewline + len("\\newline"):]
	tex = tex.replace("\\bigskip", "")
	return tex

def italReplacements(tex):
	while (tex.find("\\textit{") != -1):
		beg = tex.find("\\textit{")
		sbrace = tex.find("{", beg)
		ebrace = tex.find("}", sbrace)
		tex = tex[:beg] + tex[sbrace+1:ebrace] \
				    	+ tex[ebrace+1:]
	return tex

def oprReplacements(tex):
	while (tex.find("\\OPR") != -1):
		beg = tex.find("\\OPR")
		sbrace = tex.find("{", beg)
		ebrace = tex.find("}", beg)
		if (tex[ebrace + 1] != "."):
			tex = tex[:beg] + "\n.I " + tex[sbrace+1:ebrace] \
					    	+ "\n" + tex[ebrace+1:]
		else:
			tex = tex[:beg] + "\n.IR \"" + tex[sbrace+1:ebrace] \
					    	+ "\" .\n" + tex[ebrace+1:]
	return tex

def constReplacements(tex):
	while (tex.find("\\CONST") != -1):
		beg = tex.find("\\CONST")
		sBrace = tex.find("{", beg)
		eBrace = tex.find("}", sBrace)
		tex = tex[:beg] + tex[sBrace+1:eBrace] + tex[eBrace+1:]
	return tex

def argReplacements(tex):
	sArg = tex.find("\\begin{apiarguments}")
	eArg = tex.find("\\end{apiarguments}")
	clean = cleanText(tex[sArg:eArg])
	clean = macroReplacements(clean)
	tex = tex[:sArg] + clean + tex[eArg:]
	while(tex.find("\\apiargument") != -1):
		beg = tex.find("\\apiargument")
		fsBrace = tex.find("{", beg)
		feBrace = tex.find("}", fsBrace)
		ssBrace = feBrace + 1
		seBrace = tex.find("}", ssBrace)
		tsBrace = seBrace + 1
		teBrace = findMatchingBrace(tex, tsBrace)
		if (tex[fsBrace+1:feBrace] == "None."):
			tex = tex[:beg] + ".B None." + tex[tsBrace+1:teBrace] + tex[teBrace+1:]
		else:
			tex = tex[:beg] + "__@@__.BR \"" + tex[fsBrace+1:feBrace] \
							+ " \" -" + "\n.I " + tex[ssBrace+1:seBrace] \
							+ "\n- " + tex[tsBrace+1:teBrace] + tex[teBrace+1:]
	sArg = tex.find("\\begin{apiarguments}")
	eArg = tex.find("\\end{apiarguments}")
	clean = tex[sArg:eArg]
	clean = clean.replace("\n ", "\n")
	while(clean.find("\n\n") != -1):
		clean = clean.replace("\n\n", "\n")
	tex = tex[:sArg] + "./ sectionStart\n" + "\n.SH DESCRIPTION\n.SS Arguments\n" + \
			clean + "\n./ sectionEnd\n" + tex[eArg:]
	tex = tex.replace("\\begin{apiarguments}", "")
	tex = tex.replace("\\end{apiarguments}", "")
	return tex

def descrReplacements(tex):
	sArg = tex.find("\\apidescription{")
	eArg = findMatchingBrace(tex, tex.find("{", sArg))
	clean = cleanText(tex[sArg:eArg])
	clean = macroReplacements(clean)
	tex = tex[:sArg] + "./ sectionStart\n" + "\n.SS API Description\n" + \
			clean + "\n./ sectionEnd\n" + tex[eArg+1:]
	tex = tex.replace("\\apidescription{", "")
	return tex

def retReplacements(tex):
	sArg = tex.find("\\apireturnvalues{")
	eArg = findMatchingBrace(tex, tex.find("{", sArg))
	clean = cleanText(tex[sArg:eArg])
	clean = macroReplacements(clean)
	tex = tex[:sArg] + "./ sectionStart\n" + "\n.SS Return Values\n" + \
			clean + "\n./ sectionEnd\n" + tex[eArg + 1:]
	tex = tex.replace("\\apireturnvalues{", "")
	return tex

def notesReplacements(tex):
	sArg = tex.find("\\apinotes{")
	eArg = findMatchingBrace(tex, tex.find("{", sArg))
	clean = cleanText(tex[sArg:eArg])
	clean = macroReplacements(clean)
	tex = tex[:sArg] + "./ sectionStart\n" + "\n.SS API Notes\n" + \
			clean + "\n./ sectionEnd\n" + tex[eArg + 1:]
	tex = tex.replace("\\apinotes{", "")
	return tex

def impnotesReplacements(tex):
	sArg = tex.find("\\apiimpnotes{")
	eArg = findMatchingBrace(tex, tex.find("{", sArg))
	clean = cleanText(tex[sArg:eArg])
	clean = macroReplacements(clean)
	tex = tex[:sArg] + "./ sectionStart\n" + ".SS Note to implementors\n" + \
				clean + "\n./ sectionEnd\n" + tex[eArg + 1:]
	tex = tex.replace("\\apiimpnotes{", "")
	return tex

def sumReplacements(tex, functionName):
	sArg = tex.find("\\apisummary{")
	eArg = findMatchingBrace(tex, tex.find("{", sArg))
	clean = cleanText(tex[sArg:eArg])
	clean = clean.replace("\n", " ")
	clean = macroReplacements(clean)
	tex = tex[:sArg] + "./ sectionStart\n" + ".SH NAME\n" + functionName + " \- " \
			+ clean + "\n./ sectionEnd\n" + tex[eArg+1:]
	tex = tex.replace("\\apisummary{", "")
	return tex

def macroReplacements(clean):
	clean = variableReplacements(clean)
	clean = generalReplacements(clean)
	clean = constReplacements(clean)
	clean = oprReplacements(clean)
	clean = funcReplacements(clean)
	clean = italReplacements(clean)
	clean = clean.replace("\n ", "\n")
	clean = clean.replace("\n\n.BR ", "\n.BR ")
	clean = clean.replace("\n\n.B ", "\n.B ")
	clean = clean.replace("\n\n.I ", "\n.I ")
	clean = clean.replace("\n\n.IR ", "\n.IR ")
	return clean

def refTextReplacements(tex):
	tables = [0, 0, 0, 0, 0]
	last = 0
	while(tex.find("./ sectionEnd", last) > 0):
		fEnd = tex.find("./ sectionEnd", last)
		sStart = tex.find("./ sectionStart", fEnd)
		last = sStart
		if(tex[fEnd + len("./ sectionEnd"):sStart].strip() != ""):
			clean = tex[fEnd + len("./ sectionEnd"):sStart].strip()
			clean = cleanText(clean)
			clean = macroReplacements(clean)
			if (tex.find("\\ref{stdrmatypes}") != -1):
				clean = clean.replace("\\ref{stdrmatypes}", "1")
				tables[0] = 1
			if (tex.find("\\ref{stdamotypes}") != -1):
				clean = clean.replace("\\ref{stdamotypes}", "2")
				tables[1] = 1
			if (tex.find("\\ref{extamotypes}") != -1):
				clean = clean.replace("\\ref{extamotypes}", "3")
				tables[2] = 1
			if (tex.find("\\ref{bitamotypes}") != -1):
				clean = clean.replace("\\ref{bitamotypes}", "4")
				tables[3] = 1
			if (tex.find("\\ref{p2psynctypes}") != -1):
				clean = clean.replace("\\ref{p2psynctypes}", "5")
				tables[4] = 1

			clean = clean.replace("~", " ")
			tex = tex[:fEnd + len("./ sectionEnd\n")] + "__@@__" + clean + "\n" + tex[sStart:]
	return (tex, tables)

def refMEMReplacements(tex):
	if (tex.find("\\ref{subsec:memory_model}") != -1):
		while(tex.find("\\ref{subsec:memory_model}") != -1):
			index = tex.find("\\ref{subsec:memory_model}")
			enter = 0
			last = 0
			while (enter < index):
				last = enter
				enter = tex.find("\n", enter + 1)
			period = tex.find(".", index)
			sentence = tex[last + 1: period + 1]
			tex = tex[:last + 1] + \
				"Please refer to the subsection on the Memory Model for the" + \
				" definition of the term \"remotely accessible\"." + \
				tex[period + 1:]
	return tex

def synCReplacements(tex, keyString):
	while (tex.find("\\begin{" + keyString + "}") != -1):
		sArg = tex.find("\\begin{" + keyString + "}")
		eArg = tex.find("\\end{" + keyString + "}")
		text = tex[sArg + len("\\begin{" + keyString + "}"):eArg]
		coll = "";
		while(text.find(";") != -1):
			s = text.find("\n") + len("\n")
			e = text.find(";", s) + len(";")
			line = text[s:e]
			wordList = line.split()
			for i in xrange(len(wordList)):
				if(i < 2):
					wordList[i] = "\n.B " + wordList[i]
				else:
					if (wordList[i] in boldWordsC):
						wordList[i] = "\n.B " + wordList[i]
					else:
						if (wordList[i].find(")") != -1):
							wordList[i] = "\n.I " + wordList[i][: wordList[i].find(")")] \
											+ "\n.B )$\n"
						elif (wordList[i].find(",") != -1):
							wordList[i] = "\n.IB \"" + wordList[i][: wordList[i].find(",")] \
											+ "\" ,"
						else:
							wordList[i] = "\n.I " + wordList[i]
			line = "".join(wordList)
			coll = coll + "__@@__" + line
			text = text[e:]
		coll = coll.replace("$", ";")

		if (keyString == "C11synopsis"):
			header = ".SS C11:\n"
		elif (keyString == "Csynopsis"):
			header = ".SS C/C++:\n"
		else:
			header = ""

		tex = tex[:sArg] + "\n./ sectionStart\n" + header + coll  + \
				 "\n./ sectionEnd\n" + tex[eArg + len("\\end{" + keyString + "}"):]
	return tex

def synFReplacements(tex):
	while (tex.find("\\begin{Fsynopsis}") != -1):
		sArg = tex.find("\\begin{Fsynopsis}")
		eArg = tex.find("\\end{Fsynopsis}")
		text = tex[sArg + len("\\begin{Fsynopsis}\n"):eArg]
		text = "\n" + text.replace("\n", ";\n")
		last = 0;
		while(text.find(";") != -1):
			s = text.find("\n", last) + len("\n")
			e = text.find(";", s) + len(";")
			line = text[s:e]
			line = line.replace(";", "")
			wordList = line.split()
			if(wordList[0] in boldWordsF):
				line = ".BR \"" + wordList[0] + " \" \"" + \
						" ".join(wordList[1:]) + "\""
			text = text[:s] + line + text[e:]
			last = s
		tex = tex[:sArg ] + "\n./ sectionStart\n" + ".SS Fortran:\n" + "\n.nf\n" + text + "\n.fi\n" +\
				 "\n./ sectionEnd\n" + tex[eArg + len("\\end{Fsynopsis}"):]
	return tex

def codeReplace(tex):
	tex = synCReplacements(tex, "C11synopsis")
	tex = synCReplacements(tex, "Csynopsis")
	tex = synCReplacements(tex, "CsynopsisCol")
	tex = synFReplacements(tex)
	return tex

def descTReplacements(tex):
	arg = tex.find("\\apidesctable{")
	fsArg = tex.find("{", arg)
	feArg = findMatchingBrace(tex, fsArg)
	ssArg = tex.find("{", feArg)
	seArg = findMatchingBrace(tex, ssArg)
	tsArg = tex.find("{", seArg)
	teArg = findMatchingBrace(tex, tsArg)
	text = tex[arg:teArg+1]
	clean = cleanText(text)
	clean = clean.replace("\n", " ")
	clean = macroReplacements(clean)
	beg = tex.find("\\apidesctable{")
	fsBrace = clean.find("{")
	feBrace = clean.find("}", fsBrace)
	ssBrace = clean.find("{", feBrace)
	seBrace = clean.find("}", ssBrace)
	tsBrace = clean.find("{", seBrace)
	teBrace = clean.find("}", tsBrace)
	tex = tex[:arg] + "\n./ sectionStart\n" + clean[fsBrace+1:feBrace] + \
			"\n.TP 20\n" + clean[ssBrace+1:seBrace] + "\n" + \
			clean[tsBrace+1:teBrace] + "\n./ sectionEnd\n" + tex[teArg+1:]
	return tex

def tablReplacements(tex):
	while(tex.find("\\apitablerow") != -1):
		arg = tex.find("\\apitablerow")
		fsArg = tex.find("{", arg)
		feArg = findMatchingBrace(tex, fsArg)
		ssArg = tex.find("{", feArg)
		seArg = findMatchingBrace(tex, ssArg)
		text = tex[arg:seArg+1]

		clean = cleanText(text)
		clean = clean.replace("\n", " ")
		clean = macroReplacements(clean)
		beg = clean.find("\\apitablerow")
		fsBrace = clean.find("{", beg)
		feBrace = clean.find("}", fsBrace)
		ssBrace = clean.find("{", feBrace)
		seBrace = clean.find("}", ssBrace)
		if (clean[fsBrace+1:feBrace] != ""):
			tex = tex[:arg] + "\n./ sectionStart\n.TP 20\n" + clean[fsBrace+1:feBrace] + \
				"\n" + clean[ssBrace+1:seBrace] + "\n./ sectionEnd\n" + tex[seArg+1:]
		else:
			tex = tex[:arg] + "\n" + "\n./ sectionStart" +\
				"\n" + clean[ssBrace+1:seBrace] + "\n./ sectionEnd\n" + tex[seArg+1:]
	return tex

def parseTable(tableTex):
	startIdx = tableTex.find("\\hline")
	endIdx = tableTex.find("\\end{tabular}")
	table = cleanText(tableTex[startIdx + len("\\hline"):endIdx])
	# print(table)
	text = ""
	count = 0
	while(table.find("\\hline") >= 0):
		line = table[:table.find("\\hline")]
		firstCol = line[:line.find("&")]
		secondCol = line[line.find("&")+1:line.find("\\\\")].strip()
		if (count == 0):
			text += ".TP 20\n" + ".B " + firstCol + "\n.B " + secondCol + "\n"
		else:
			text += ".TP\n" + firstCol + "\n" + secondCol + "\n"
		table = table[table.find("\\hline") + len("\\hline"):]
		count += 1
	return text


def table(tableID, directory):
	if tableID == 1:
		tableTex = open(directory + "stdrmatypes.tex", "r").read()
	elif tableID == 2: 
		tableTex = open(directory + "stdamotypes.tex", "r").read()
	elif tableID == 3:
		tableTex = open(directory + "extamotypes.tex", "r").read()
	elif tableID == 4:
		tableTex = open(directory + "bitamotypes.tex", "r").read()
	else:
		tableTex = open(directory + "p2psynctypes.tex", "r").read()
	captionIdx = tableTex.find("\\caption{")
	startBrace = captionIdx + len("\\caption{")
	endBrace = findMatchingBrace(tableTex, startBrace)

	caption = generalReplacements(tableTex[startBrace:endBrace])
	text = ".SS Table " + str(tableID) + ":\n" + caption + "\n" + \
			parseTable(tableTex)
	return text


def exampleReplacements(tex):
	sArg = tex.find("\\begin{apiexamples}")
	eArg = tex.find("\\end{apiexamples}")
	text = tex[sArg + len("\\begin{apiexamples}"):eArg]
	clean = cleanText(text)

	clean = clean.replace("\n", " ")
	clean = macroReplacements(clean)

	while(clean.find("\\apicexample") != -1):
		beg = clean.find("\\apicexample")
		fsBrace = clean.find("{", beg)
		feBrace = clean.find("}", fsBrace)
		ssBrace = clean.find("{", feBrace)
		seBrace = clean.find("}", ssBrace)
		tsBrace = clean.find("{", seBrace)
		teBrace = clean.find("}", tsBrace)
		pathS = clean.find("example_code", beg)
		path = clean[pathS:seBrace]
		ex = open("../" + path, "r").read()
		clean = clean[:beg] + "\n" + clean[fsBrace+1:feBrace] + "\n\n.nf\n" + ex \
		+ ".fi\n" + clean[tsBrace+1:teBrace] + clean[teBrace + 1:]
	while(clean.find("\\apifexample") != -1):
		beg = clean.find("\\apifexample")
		fsBrace = clean.find("{", beg)
		feBrace = clean.find("}", fsBrace)
		ssBrace = clean.find("{", feBrace)
		seBrace = clean.find("}", ssBrace)
		tsBrace = clean.find("{", seBrace)
		teBrace = clean.find("}", tsBrace)
		pathS = clean.find("example_code", beg)
		pathE = clean.find("}", pathS)
		path = clean[ssBrace+1:seBrace].strip()
		ex = open("../" + path, "r").read()
		clean = clean[:beg] + "\n" + clean[fsBrace+1:feBrace] + "\n\n.nf\n" + ex \
		+ ".fi\n" + clean[tsBrace+1:teBrace] + clean[teBrace + 1:]
	
	tex = tex[:sArg] + "./ sectionStart" + "\n.SS Examples\n" + clean \
				 + tex[eArg + len("\\end{apiexamples}"):]
	return tex

def cleanText(text):
	text = text.replace("\t", "")
	
	while(text.find("  ") != -1):
		text = text.replace("  ", " ")
	text = text.replace("\n ", "\n")
	text = text.replace("\n\n", "__@@__")
	return text

def findMatchingBrace(tex, ind):
	count = 1
	ptr = ind
	while(count != 0):
		ptr = ptr + 1
		if(tex[ptr] == "{"):
			count = count + 1
		if(tex[ptr] == "}"):
			count = count - 1
	return ptr

def convertFile(functionName, directory):
		filename = directory + functionName + ".tex"

		texFile = open(filename, "r")
		if not os.path.exists("../man"):
			os.makedirs("../man")
		manFile = open("../man/" + functionName + ".3", "w")
		titleHeader = writeTH(functionName)
		manFile.write(titleHeader)

		tex = texFile.read()
		tex = tex.replace("\\begin{DeprecateBlock}", "")
		tex = tex.replace("\\end{DeprecateBlock}", "")
		tex = tex.replace("\\begin{apidefinition}\n", "./ sectionStart\n.SH   SYNOPSIS\n./ sectionEnd")
		tex = sumReplacements(tex, functionName)
		tex = mBoxReplacements(tex)
		tex = argReplacements(tex)
		tex = descrReplacements(tex)
		tex = notesReplacements(tex)
		tex = retReplacements(tex)
		tex = boldReplacements(tex)
		tex = codeReplace(tex)
		if (tex.find("\\apiimpnotes{") != -1):
			tex = impnotesReplacements(tex)
		while(tex.find("\\apidesctable{") != -1):
			tex = descTReplacements(tex)
		tex = tablReplacements(tex)
		tex = refMEMReplacements(tex)
		if (tex.find("\\begin{apiexamples}") != -1):
			tex = exampleReplacements(tex)
		(tex, tables) = refTextReplacements(tex)
		if (tables[0]):
			tex = tex + table(1, directory)
		if (tables[1]):
			tex = tex + table(2, directory)
		if (tables[2]):
			tex = tex + table(3, directory)
		if (tables[3]):
			tex = tex + table(4, directory)
		if (tables[4]):
			tex = tex + table(5, directory)
		tex = tex.replace("\\begin{apidefinition}", "")
		tex = tex.replace("\\end{apidefinition}", "")
		text = tex[:tex.find(".SS Examples")]
		while(text.find("\n\n") != -1):
			text = text.replace("\n\n", "\n")
		while(text.find("\n ") != -1):
			text = text.replace("\n ", "\n")
		text = text.replace("\\\\", "\n")
		text = text.replace("$", "")
		tex = text + tex[tex.find(".SS Examples"):]
		tex = tex.replace("__@@__", "\n\n")
		tex = tex.replace("\n ", "\n")
		manFile.write(tex.replace("\\n", "\\\\" + "n"))
		print("Finished converting " + functionName + ".tex")
		manFile.close()
		texFile.close()

def main():
		parser = argparse.ArgumentParser(description='Generate OpenSHMEM manpages')
		parser.add_argument('-d', '--directory', type=str, required=False,
                            help='OpenSHMEM specification LaTeX directory path')
		parser.add_argument('-f', '--filename', type=str, required=False,
                            help='LaTeX file path for an OpenSHMEM routine')
		args = parser.parse_args()

		if (args.directory == None) and (args.filename == None):
			parser.print_usage()
			exit(1)
        #Check that the directory exists
		# print(args.directory)
		if args.directory != None:
			if args.directory[-1] != "/":
				args.directory += "/"
			if not os.path.realpath(args.directory):
				print("Error: input directory, " + args.directory + ", does not appear to exist")
				exit(1)
			else:
				print("Dir found")
				for routine in routineList:
					if routine + ".tex" not in os.listdir(args.directory):
						print("Error: " + routine + ".tex is not in the given directory")
						exit(1)
					else:
						convertFile(routine, args.directory)
		else:
			if not os.path.isfile(args.filename):
				print("Error: input file, " + args.filename + ", does not appear to exist.")
				exit(1)
			else:
				per = args.filename.find(".tex")
				last = 0;
				# print(args.filename.find("/", last))
				while (args.filename.find("/", last) >= 0):
					last = args.filename.find("/", last) + 1
					# print(last)
				functionName = args.filename[last:per]
				# print(functionName)
				if functionName not in routineList:
					print("WARNING: This function is not in the list of parsable routines. May result in undefined behavior.")
				convertFile(functionName, args.filename[:last])



if __name__== "__main__":
    main()
