#!/usr/bin/env python

# For getting the arguments directly from command line
import sys
import os
import string
import datetime
import argparse

boldWordsC = {"void", "int", "const", "size_t", "short", "ptrdiff_t", "long", "TYPE", "shmem_global_exit(int"}
boldWordsF = {"INTEGER", "CALL", "POINTER", "LOGICAL", "INTEGER*4",
				"INTEGER*8", "REAL*4", "REAL*8", "CHARACTER"}
routineList = ["shmem_init", "shmem_n_pes", "shmem_my_pes", "shmem_finalize", "shmem_global_exit", "shmem_get_name_info", 
				"shmem_addr_info"]


def writeTH(functionName):
	titleHeader = ".TH " + functionName.upper() + " 3 " \
					 + "" + " " \
					 + "\"Open Source Software Solutions, Inc.\"" + " " \
					 + "\"OpenSHEMEM Library Documentation\"" + "\n"
	return titleHeader

def generalReplacements(tex):
	tex = tex.replace("\openshmem{}", "OpenSHMEM")
	tex = tex.replace("\openshmem", "OpenSHMEM")
	tex = tex.replace("\\acp{PE}", "PEs")
	tex = tex.replace("\\ac{PE}", "PE")
	tex = tex.replace("\\ac{MPI}", "MPI")
	tex = tex.replace("\\acp{AMO}", "AMOs")
	tex = tex.replace("\\ac{AMO}", "AMO")
	tex = tex.replace("\\ac{API}", "API")
	tex = tex.replace("\\acp{RMA}", "RMAs")
	tex = tex.replace("\\ac{RMA}", "RMA")
	tex = tex.replace("\\CorCpp{}", " C/C++")
	tex = tex.replace("\\CorCpp", " C/C++")
	tex = tex.replace("\\Fortran{}", "Fortran")
	tex = tex.replace("\\Fortran", "Fortran")
	tex = tex.replace("\\Cstd", "C")
	tex = tex.replace("\\PUT{}", "PUT")
	tex = tex.replace("\\GET{}", "GET")
	tex = tex.replace("\\SIZE{}", "SIZE")
	tex = tex.replace("\\activeset.", "\n.IR \"Active set\" .\n")
	tex = tex.replace("\\activeset{}", "\\activeset")
	tex = tex.replace("\\activeset", "\n.I \"Active set\"\n")
	tex = tex.replace("\\activeset ", "\n.I \"Active set\"\n")
	tex = tex.replace("\\dest.", "\n.IR \"dest\" .\n")
	tex = tex.replace("\\source.", "\n.IR \"source\" .\n")
	tex = tex.replace("\\dest{}", "\n.I \"dest\"\n")
	tex = tex.replace("\\source{}", "\n.I \"source\"\n")
	return tex

def funcReplacements(tex):
	while (tex.find("\FUNC{") != -1):
		beg = tex.find("\FUNC{")
		brace = tex.find("}", beg)
		if(tex[brace + 1] == "."):
			tex = tex[:beg] + "\n.BR \"" + tex[beg+len("\FUNC{"):brace] \
								+  "\" .\n" + tex[brace+2:]
		else:
			if(tex[brace + 1] == " "):
				tex = tex[:beg] + "\n.B " + tex[beg+len("\FUNC{"):brace] \
								+ "\n" + tex[brace+2:]
			else:
				tex = tex[:beg] + "\n.B " + tex[beg+len("\FUNC{"):brace] \
								+ "\n" + tex[brace+1:]
	return tex

def varReplacements(tex, keyString):
	while (tex.find(keyString) != -1):
		beg = tex.find(keyString)
		sbrace = tex.find("{", beg)
		ebrace = tex.find("}", sbrace)
		innerText = tex[sbrace+1:ebrace]
                if keyString == "\VARTH":
			innerText += "th"
		if (tex[ebrace + 1] != "."):
			tex = tex[:beg] + "\n.I " + innerText \
					    	+ "\n" + tex[ebrace+1:]
		else:
			tex = tex[:beg] + "\n.IR \"" + innerText \
					    	+ "\" .\n" + tex[ebrace+1:]
	return tex

def variableReplacements(tex):
	varReplacements(tex, "\VAR")
	varReplacements(tex, "\VARTH")

def mBoxReplacements(tex):
	while (tex.find("|\mbox") != -1):
		beg = tex.find("|\mbox")
		sbrace = tex.find("{", beg)
		ebrace = tex.find("}", sbrace)
		ebar = tex.find("|", sbrace)
		tex = tex[:beg] + tex[sbrace+1:ebrace] \
					    + tex[ebar+1:]
	return tex

def boldReplacements(tex):
	while (tex.find("\\textbf{") != -1):
		beg = tex.find("\\textbf{")
		sbrace = tex.find("{", beg)
		ebrace = tex.find("}", sbrace)
		fnewline = tex.find("\\newline", ebrace)
		snewline = tex.find("\\newline", fnewline + 1)
		clean = tex[fnewline + len("\\newline"):snewline]
		clean = macroReplacements(clean)
		tex = tex[:beg] + "\n.SH " + tex[sbrace+1:ebrace] \
				    	+ "\n" + clean \
				    	+ tex[snewline + len("\\newline"):]
	tex = tex.replace("\\bigskip", "")
	return tex

def italReplacements(tex):
	while (tex.find("\\textit{") != -1):
		beg = tex.find("\\textit{")
		sbrace = tex.find("{", beg)
		ebrace = tex.find("}", sbrace)
		tex = tex[:beg] + tex[sbrace+1:ebrace] \
				    	+ tex[ebrace+1:]
	return tex

def oprReplacements(tex):
	while (tex.find("\\OPR") != -1):
		beg = tex.find("\\OPR")
		sbrace = tex.find("{", beg)
		ebrace = tex.find("}", beg)
		if (tex[ebrace + 1] != "."):
			tex = tex[:beg] + "\n.I " + tex[sbrace+1:ebrace] \
					    	+ "\n" + tex[ebrace+1:]
		else:
			tex = tex[:beg] + "\n.IR \"" + tex[sbrace+1:ebrace] \
					    	+ "\" .\n" + tex[ebrace+1:]
	return tex

def constReplacements(tex):
	while (tex.find("\\CONST") != -1):
		beg = tex.find("\\CONST")
		sBrace = tex.find("{", beg)
		eBrace = tex.find("}", sBrace)
		tex = tex[:beg] + tex[sBrace+1:eBrace] + tex[eBrace+1:]
	return tex

def argReplacements(tex):
	sArg = tex.find("\\begin{apiarguments}")
	eArg = tex.find("\\end{apiarguments}")
	clean = cleanText(tex[sArg:eArg])
	clean = macroReplacements(clean)
	tex = tex[:sArg] + clean + tex[eArg:]
	while(tex.find("\\apiargument") != -1):
		beg = tex.find("\\apiargument")
		fsBrace = tex.find("{", beg)
		feBrace = tex.find("}", fsBrace)
		ssBrace = feBrace + 1
		seBrace = tex.find("}", ssBrace)
		tsBrace = seBrace + 1
		teBrace = findMatchingBrace(tex, tsBrace)
		if (tex[fsBrace+1:feBrace] == "None."):
			tex = tex[:beg] + ".B None." + tex[tsBrace+1:teBrace] + tex[teBrace+1:]
		else:
			tex = tex[:beg] + "@.BR \"" + tex[fsBrace+1:feBrace] \
							+ " \" -" + "\n.I " + tex[ssBrace+1:seBrace] \
							+ "\n- " + tex[tsBrace+1:teBrace] + tex[teBrace+1:]
	sArg = tex.find("\\begin{apiarguments}")
	eArg = tex.find("\\end{apiarguments}")
	clean = tex[sArg:eArg]
	clean = clean.replace("\n ", "\n")
	while(clean.find("\n\n") != -1):
		clean = clean.replace("\n\n", "\n")
	tex = tex[:sArg] + "./ sectionStart\n" + "\n.SH DESCRIPTION\n.SS Arguments\n" + \
			clean + "\n./ sectionEnd\n" + tex[eArg:]
	tex = tex.replace("\\begin{apiarguments}", "")
	tex = tex.replace("\\end{apiarguments}", "")
	return tex

def descrReplacements(tex):
	sArg = tex.find("\\apidescription{")
	eArg = findMatchingBrace(tex, tex.find("{", sArg))
	clean = cleanText(tex[sArg:eArg])
	clean = macroReplacements(clean)
	tex = tex[:sArg] + "./ sectionStart\n" + "\n.SS API Description\n" + \
			clean + "\n./ sectionEnd\n" + tex[eArg+1:]
	tex = tex.replace("\\apidescription{", "")
	return tex

def retReplacements(tex):
	sArg = tex.find("\\apireturnvalues{")
	eArg = findMatchingBrace(tex, tex.find("{", sArg))
	clean = cleanText(tex[sArg:eArg])
	clean = macroReplacements(clean)
	tex = tex[:sArg] + "./ sectionStart\n" + "\n.SS Return Values\n" + \
			clean + "\n./ sectionEnd\n" + tex[eArg + 1:]
	tex = tex.replace("\\apireturnvalues{", "")
	return tex

def notesReplacements(tex):
	sArg = tex.find("\\apinotes{")
	eArg = findMatchingBrace(tex, tex.find("{", sArg))
	clean = cleanText(tex[sArg:eArg])
	clean = macroReplacements(clean)
	tex = tex[:sArg] + "./ sectionStart\n" + "\n.SS API Notes\n" + \
			clean + "\n./ sectionEnd\n" + tex[eArg + 1:]
	tex = tex.replace("\\apinotes{", "")
	return tex

def impnotesReplacements(tex):
	sArg = tex.find("\\apiimpnotes{")
	eArg = findMatchingBrace(tex, tex.find("{", sArg))
	clean = cleanText(tex[sArg:eArg])
	clean = macroReplacements(clean)
	tex = tex[:sArg] + "./ sectionStart\n" + ".SS Note to implementors\n" + \
				clean + "\n./ sectionEnd\n" + tex[eArg + 1:]
	tex = tex.replace("\\apiimpnotes{", "")
	return tex

def sumReplacements(tex, functionName):
	sArg = tex.find("\\apisummary{")
	eArg = findMatchingBrace(tex, tex.find("{", sArg))
	clean = cleanText(tex[sArg:eArg])
	clean = clean.replace("\n", " ")
	clean = macroReplacements(clean)
	tex = tex[:sArg] + "./ sectionStart\n" + ".SH NAME\n" + functionName + " \- " \
			+ clean + "\n./ sectionEnd\n" + tex[eArg+1:]
	tex = tex.replace("\\apisummary{", "")
	return tex

def macroReplacements(clean):
	clean = varReplacements(clean)
	clean = generalReplacements(clean)
	clean = constReplacements(clean)
	clean = oprReplacements(clean)
	clean = funcReplacements(clean)
	clean = italReplacements(clean)
	clean = clean.replace("\n ", "\n")
	clean = clean.replace("\n\n.BR ", "\n.BR ")
	clean = clean.replace("\n\n.B ", "\n.B ")
	clean = clean.replace("\n\n.I ", "\n.I ")
	clean = clean.replace("\n\n.IR ", "\n.IR ")
	return clean

def refTextReplacements(tex):
	tables = [0, 0, 0, 0, 0]
	ref1 = "* For details on TYPE and TYPENAME, please refer to Table 1 below."
	ref2 = "* TYPE is one of the standard AMO types. For details, please refer to Table 2 below."
	ref3 = "* TYPE is one of the extended AMO types. For details, please refer to Table 3 below."
	ref4 = "* TYPE is one of the bitwise AMO types. For details, please refer to Table 4 below."
	ref5 = "* TYPE is one of the point-to-point synchronization types. For details, please refer to Table 5 below."
	last = 0
	while(tex.find("./ sectionEnd", last) > 0):
		fEnd = tex.find("./ sectionEnd", last)
		sStart = tex.find("./ sectionStart", fEnd)
		last = sStart
		if(tex[fEnd + len("./ sectionEnd"):sStart].strip() != ""):
			if (tex.find("\\ref{stdrmatypes}") != -1):
				tex = tex[:fEnd + len("./ sectionEnd\n")] + "@" + ref1 + "\n" + tex[sStart:]
				tables[0] = 1
			elif (tex.find("\\ref{stdamotypes}") != -1):
				tex = tex[:fEnd + len("./ sectionEnd\n")] + "@" + ref2 + "\n" + tex[sStart:]
				tables[1] = 1
			elif (tex.find("\\ref{extamotypes}") != -1):
				tex = tex[:fEnd + len("./ sectionEnd\n")] + "@" + ref3 + "\n" + tex[sStart:]
				tables[2] = 1
			elif (tex.find("\\ref{bitamotypes}") != -1):
				tex = tex[:fEnd + len("./ sectionEnd\n")] + "@" + ref4 + "\n" + tex[sStart:]
				tables[3] = 1
			elif (tex.find("\\ref{p2psynctypes}") != -1):
				tex = tex[:fEnd + len("./ sectionEnd\n")] + "@" + ref5 + "\n" + tex[sStart:]
				tables[4] = 1
			else:
				text = tex[fEnd + len("./ sectionEnd\n"):sStart]
				clean = cleanText(text)
				clean = macroReplacements(clean)
				tex = tex[:fEnd + len("./ sectionEnd\n")] + "@" + clean + "\n" + tex[sStart:]
	return (tex, tables)

def refMEMReplacements(tex):
	if (tex.find("\\ref{subsec:memory_model}") != -1):
		while(tex.find("\\ref{subsec:memory_model}") != -1):
			index = tex.find("\\ref{subsec:memory_model}")
			enter = 0
			last = 0
			while (enter < index):
				last = enter
				enter = tex.find("\n", enter + 1)
			period = tex.find(".", index)
			sentence = tex[last + 1: period + 1]
			tex = tex[:last + 1] + \
				"Please refer to the subsection on the Memory Model for the" + \
				" definition of the term \"remotely accessible\"." + \
				tex[period + 1:]
	return tex

def synCReplacements(tex, keyString):
	while (tex.find("\\begin{" + keyString + "}") != -1):
		sArg = tex.find("\\begin{" + keyString + "}")
		eArg = tex.find("\\end{" + keyString + "}")
		text = tex[sArg + len("\\begin{" + keyString + "}"):eArg]
		coll = "";
		while(text.find(";") != -1):
			s = text.find("\n") + len("\n")
			e = text.find(";", s) + len(";")
			line = text[s:e]
			wordList = line.split()
			for i in xrange(len(wordList)):
				if(i < 2):
					wordList[i] = "\n.B " + wordList[i]
				else:
					if (wordList[i] in boldWordsC):
						wordList[i] = "\n.B " + wordList[i]
					else:
						if (wordList[i].find(")") != -1):
							wordList[i] = "\n.I " + wordList[i][: wordList[i].find(")")] \
											+ "\n.B )$\n"
						elif (wordList[i].find(",") != -1):
							wordList[i] = "\n.IB \"" + wordList[i][: wordList[i].find(",")] \
											+ "\" ,"
						else:
							wordList[i] = "\n.I " + wordList[i]
			line = "".join(wordList)
			coll = coll + "@" + line
			text = text[e:]
		coll = coll.replace("$", ";")

		if (keyString == "C11synopsis"):
			header = ".SS C11:\n"
		elif (keyString == "Csynopsis"):
			header = ".SS C/C++:\n"
		else:
			header = ""

		tex = tex[:sArg] + "\n./ sectionStart\n" + header + coll  + \
				 "\n./ sectionEnd\n" + tex[eArg + len("\\end{" + keyString + "}"):]
	return tex

def synFReplacements(tex):
	while (tex.find("\\begin{Fsynopsis}") != -1):
		sArg = tex.find("\\begin{Fsynopsis}")
		eArg = tex.find("\\end{Fsynopsis}")
		text = tex[sArg + len("\\begin{Fsynopsis}\n"):eArg]
		text = "\n" + text.replace("\n", ";\n")
		last = 0;
		while(text.find(";") != -1):
			s = text.find("\n", last) + len("\n")
			e = text.find(";", s) + len(";")
			line = text[s:e]
			line = line.replace(";", "")
			wordList = line.split()
			if(wordList[0] in boldWordsF):
				line = ".BR \"" + wordList[0] + " \" \"" + \
						" ".join(wordList[1:]) + "\""
			text = text[:s] + line + text[e:]
			last = s
		tex = tex[:sArg ] + "\n./ sectionStart\n" + ".SS Fortran:\n" + "\n.nf\n" + text + "\n.fi\n" +\
				 "\n./ sectionEnd\n" + tex[eArg + len("\\end{Fsynopsis}"):]
	return tex

def codeReplace(tex):
	tex = synCReplacements(tex, "C11synopsis")
	tex = synCReplacements(tex, "Csynopsis")
	tex = synCReplacements(tex, "CsynopsisCol")
	tex = synFReplacements(tex)
	return tex

def descTReplacements(tex):
	arg = tex.find("\\apidesctable{")
	fsArg = tex.find("{", arg)
	feArg = findMatchingBrace(tex, fsArg)
	ssArg = tex.find("{", feArg)
	seArg = findMatchingBrace(tex, ssArg)
	tsArg = tex.find("{", seArg)
	teArg = findMatchingBrace(tex, tsArg)
	text = tex[arg:teArg+1]
	clean = cleanText(text)
	clean = clean.replace("\n", " ")
	clean = macroReplacements(clean)
	beg = tex.find("\\apidesctable{")
	fsBrace = clean.find("{")
	feBrace = clean.find("}", fsBrace)
	ssBrace = clean.find("{", feBrace)
	seBrace = clean.find("}", ssBrace)
	tsBrace = clean.find("{", seBrace)
	teBrace = clean.find("}", tsBrace)
	tex = tex[:arg] + "\n./ sectionStart\n" + clean[fsBrace+1:feBrace] + \
			"\n.TP 20\n" + clean[ssBrace+1:seBrace] + "\n" + \
			clean[tsBrace+1:teBrace] + "\n./ sectionEnd\n" + tex[teArg+1:]
	return tex

def tablReplacements(tex):
	while(tex.find("\\apitablerow") != -1):
		arg = tex.find("\\apitablerow")
		fsArg = tex.find("{", arg)
		feArg = findMatchingBrace(tex, fsArg)
		ssArg = tex.find("{", feArg)
		seArg = findMatchingBrace(tex, ssArg)
		text = tex[arg:seArg+1]

		clean = cleanText(text)
		clean = clean.replace("\n", " ")
		clean = macroReplacements(clean)
		beg = clean.find("\\apitablerow")
		fsBrace = clean.find("{", beg)
		feBrace = clean.find("}", fsBrace)
		ssBrace = clean.find("{", feBrace)
		seBrace = clean.find("}", ssBrace)
		if (clean[fsBrace+1:feBrace] != ""):
			tex = tex[:arg] + "\n./ sectionStart\n.TP 20\n" + clean[fsBrace+1:feBrace] + \
				"\n" + clean[ssBrace+1:seBrace] + "\n./ sectionEnd\n" + tex[seArg+1:]
		else:
			tex = tex[:arg] + "\n" + "\n./ sectionStart" +\
				"\n" + clean[ssBrace+1:seBrace] + "\n./ sectionEnd\n" + tex[seArg+1:]
	return tex

def table1():
	return ".SS Table 1: \n" + \
	".TP 20\n" + \
	".B TYPE\n" + \
	".B TYPENAME\n" + \
	".TP\n" + \
	"float\n" + \
	"float\n" + \
	".TP\n" + \
	"double\n" + \
	"double\n" + \
	".TP\n" + \
	"long double\n" + \
	"longdouble\n" + \
	".TP\n" + \
	"char\n" + \
	"char\n" + \
	".TP\n" + \
	"signed char\n" + \
	"schar\n" + \
	".TP\n" + \
	"short\n" + \
	"short\n" + \
	".TP\n" + \
	"int\n" + \
	"int\n" + \
	".TP\n" + \
	"long\n" + \
	"long\n" + \
	".TP\n" + \
	"long long\n" + \
	"longlong\n" + \
	".TP\n" + \
	"unsigned char\n" + \
	"uchar\n" + \
	".TP\n" + \
	"unsigned short\n" + \
	"ushort\n" + \
	".TP\n" + \
	"unsigned int\n" + \
	"uint\n" + \
	".TP\n" + \
	"unsigned long\n" + \
	"ulong\n" + \
	".TP\n" + \
	"unsigned long long\n" + \
	"ulonglong\n" + \
	".TP\n" + \
	"int8_t\n" + \
	"int8\n" + \
	".TP\n" + \
	"int16_t\n" + \
	"int16\n" + \
	".TP\n" + \
	"int32_t\n" + \
	"int32\n" + \
	".TP\n" + \
	"int64_t\n" + \
	"int64\n" + \
	".TP\n" + \
	"uint8_t\n" + \
	"uint8\n" + \
	".TP\n" + \
	"uint16_t\n" + \
	"uint16\n" + \
	".TP\n" + \
	"uint32_t\n" + \
	"uint32\n" + \
	".TP\n" + \
	"uint64_t\n" + \
	"uint64\n" + \
	".TP\n" + \
	"size_t\n" + \
	"size\n" + \
	".TP\n" + \
	"ptrdiff_t\n" + \
	"ptrdiff\n" 

def table2():
	return ".SS Table 2: \n" + \
	".TP 20\n" + \
	".B TYPE\n" + \
	".B TYPENAME\n" + \
	".TP\n" + \
	"int\n" + \
	"int\n" + \
	".TP\n" + \
	"long\n" + \
	"long\n" + \
	".TP\n" + \
	"long long\n" + \
	"longlong\n" + \
	".TP\n" + \
	"unsigned int\n" + \
	"uint\n" + \
	".TP\n" + \
	"unsigned long\n" + \
	"ulong\n" + \
	".TP\n" + \
	"unsigned long long\n" + \
	"ulonglong\n" + \
	".TP\n" + \
	"int32_t\n" + \
	"int32\n" + \
	".TP\n" + \
	"int64_t\n" + \
	"int64\n" + \
	".TP\n" + \
	"uint32_t\n" + \
	"uint32\n" + \
	".TP\n" + \
	"uint64_t\n" + \
	"uint64\n" + \
	".TP\n" + \
	"size_t\n" + \
	"size\n" + \
	".TP\n" + \
	"ptrdiff_t\n" + \
	"ptrdiff\n" 

def table3():
	return ".SS Table 3: \n" + \
	".TP 20\n" + \
	".B TYPE\n" + \
	".B TYPENAME\n" + \
	".TP\n" + \
	"float\n" + \
	"float\n" + \
	".TP\n" + \
	"double\n" + \
	"double\n" + \
	".TP\n" + \
	"int\n" + \
	"int\n" + \
	".TP\n" + \
	"long\n" + \
	"long\n" + \
	".TP\n" + \
	"long long\n" + \
	"longlong\n" + \
	".TP\n" + \
	"unsigned int\n" + \
	"uint\n" + \
	".TP\n" + \
	"unsigned long\n" + \
	"ulong\n" + \
	".TP\n" + \
	"unsigned long long\n" + \
	"ulonglong\n" + \
	".TP\n" + \
	"int32_t\n" + \
	"int32\n" + \
	".TP\n" + \
	"int64_t\n" + \
	"int64\n" + \
	".TP\n" + \
	"uint32_t\n" + \
	"uint32\n" + \
	".TP\n" + \
	"uint64_t\n" + \
	"uint64\n" + \
	".TP\n" + \
	"size_t\n" + \
	"size\n" + \
	".TP\n" + \
	"ptrdiff_t\n" + \
	"ptrdiff\n" 

def table4():
	return ".SS Table 4: \n" + \
	".TP 20\n" + \
	".B TYPE\n" + \
	".B TYPENAME\n" + \
	".TP\n" + \
	"unsigned int\n" + \
	"uint\n" + \
	".TP\n" + \
	"unsigned long\n" + \
	"ulong\n" + \
	".TP\n" + \
	"unsigned long long\n" + \
	"ulonglong\n" + \
	".TP\n" + \
	"int32_t\n" + \
	"int32\n" + \
	".TP\n" + \
	"int64_t\n" + \
	"int64\n" + \
	".TP\n" + \
	"uint32_t\n" + \
	"uint32\n" + \
	".TP\n" + \
	"uint64_t\n" + \
	"uint64\n"

def table5():
	return ".SS Table 5: \n" + \
		".TP 20\n" + \
		".B TYPE\n" + \
		".B TYPENAME\n" + \
		".TP\n" + \
		"short\n" + \
		"short\n" + \
		".TP\n" + \
		"int\n" + \
		"int\n" + \
		".TP\n" + \
		"long\n" + \
		"long\n" + \
		".TP\n" + \
		"long long\n" + \
		"longlong\n" + \
		".TP\n" + \
		"unsigned int\n" + \
		"uint\n" + \
		".TP\n" + \
		"unsigned short\n" + \
		"ushort\n" + \
		".TP\n" + \
		"unsigned long\n" + \
		"ulong\n" + \
		".TP\n" + \
		"unsigned long long\n" + \
		"ulonglong\n" + \
		".TP\n" + \
		"int32_t\n" + \
		"int32\n" + \
		".TP\n" + \
		"int64_t\n" + \
		"int64\n" + \
		".TP\n" + \
		"uint32_t\n" + \
		"uint32\n" + \
		".TP\n" + \
		"uint64_t\n" + \
		"uint64\n" + \
		".TP\n" + \
		"size_t\n" + \
		"size\n" + \
		".TP\n" + \
		"ptrdiff_t\n" + \
		"ptrdiff\n"

def exampleReplacements(tex):
	sArg = tex.find("\\begin{apiexamples}")
	eArg = tex.find("\\end{apiexamples}")
	text = tex[sArg + len("\\begin{apiexamples}"):eArg]
	clean = cleanText(text)

	clean = clean.replace("\n", " ")
	clean = macroReplacements(clean)

	while(clean.find("\\apicexample") != -1):
		beg = clean.find("\\apicexample")
		fsBrace = clean.find("{", beg)
		feBrace = clean.find("}", fsBrace)
		ssBrace = clean.find("{", feBrace)
		seBrace = clean.find("}", ssBrace)
		tsBrace = clean.find("{", seBrace)
		teBrace = clean.find("}", tsBrace)
		pathS = clean.find("example_code", beg)
		path = clean[pathS:seBrace]
		ex = open("../" + path, "r").read()
		clean = clean[:beg] + "\n" + clean[fsBrace+1:feBrace] + "\n\n.nf\n" + ex \
		+ ".fi\n" + clean[tsBrace+1:teBrace] + clean[teBrace + 1:]
	while(clean.find("\\apifexample") != -1):
		beg = clean.find("\\apifexample")
		fsBrace = clean.find("{", beg)
		feBrace = clean.find("}", fsBrace)
		ssBrace = clean.find("{", feBrace)
		seBrace = clean.find("}", ssBrace)
		tsBrace = clean.find("{", seBrace)
		teBrace = clean.find("}", tsBrace)
		pathS = clean.find("example_code", beg)
		pathE = clean.find("}", pathS)
		path = clean[ssBrace+1:seBrace].strip()
		ex = open("../" + path, "r").read()
		clean = clean[:beg] + "\n" + clean[fsBrace+1:feBrace] + "\n\n.nf\n" + ex \
		+ ".fi\n" + clean[tsBrace+1:teBrace] + clean[teBrace + 1:]
	
	tex = tex[:sArg] + "./ sectionStart" + "\n.SS Examples\n" + clean \
				 + tex[eArg + len("\\end{apiexamples}"):]
	return tex

def cleanText(text):
	text = text.replace("\t", "")
	
	while(text.find("  ") != -1):
		text = text.replace("  ", " ")
	text = text.replace("\n ", "\n")
	text = text.replace("\n\n", "@")
	return text

def findMatchingBrace(tex, ind):

	count = 1
	ptr = ind
	while(count != 0):
		ptr = ptr + 1
		if(tex[ptr] == "{"):
			count = count + 1
		if(tex[ptr] == "}"):
			count = count - 1
	return ptr

def main():
        parser = argparse.ArgumentParser(description='Generate OpenSHMEM manpages')
        parser.add_argument('-d', '--directory', type=str, required=False,
                            help='OpenSHMEM specification LaTeX directory path')
        parser.add_argument('-f', '--filename', type=str, required=False,
                            help='LaTeX file path for an OpenSHMEM routine')
        args = parser.parse_args()

        if (args.directory == None) and (args.filename == None):
            parser.print_usage()
            exit(1)

        import pdb; pdb.set_trace()
        #Check that the directory exists
        if args.directory != None:
            if not os.path.isdir(args.directory):
                print("Error: input directory, " + args.directory + ", does not appear to exist")
                exit(1)

            #TODO: For each file gathered from TOC:
            #if not os.path.exists(myfile):
            #    print "Error: " + myfile + "doesn't exist"
            #    exit(1)

        if args.filename != None:
            if not os.path.exists(args.filename):
                print("Error: input file, " + args.filename + ", does not appear to exist")

	    filename = args.filename
	    per = filename.find(".tex")
	    last = 0;
	    while (filename.find("/", last) > 0):
	    	last = filename.find("/", last) + 1
	    functionName = filename[last:per]

	    texFile = open(filename, "r")
	    manFile = open("../man/" + functionName + ".3", "w")
	    titleHeader = writeTH(functionName)
	    manFile.write(titleHeader)


	    tex = texFile.read()
	    tex = tex.replace("\\begin{DeprecateBlock}", "")
	    tex = tex.replace("\\end{DeprecateBlock}", "")

	    tex = tex.replace("\\begin{apidefinition}\n", "./ sectionStart\n.SH   SYNOPSIS\n./ sectionEnd")
	    tex = sumReplacements(tex, functionName)
	    tex = mBoxReplacements(tex)
	    tex = argReplacements(tex)
	    tex = descrReplacements(tex)
	    tex = notesReplacements(tex)
	    tex = retReplacements(tex)
	    tex = boldReplacements(tex)
	    tex = codeReplace(tex)
	    if (tex.find("\\apiimpnotes{") != -1):
	    	tex = impnotesReplacements(tex)
	    while(tex.find("\\apidesctable{") != -1):
	    	tex = descTReplacements(tex)
	    tex = tablReplacements(tex)
	    tex = refMEMReplacements(tex)
	    if (tex.find("\\begin{apiexamples}") != -1):
	    	tex = exampleReplacements(tex)
	    (tex, tables) = refTextReplacements(tex)
	    if (tables[0]):
	    	tex = tex + table1()
	    if (tables[1]):
	    	tex = tex + table2()
	    if (tables[2]):
	    	tex = tex + table3()
	    if (tables[3]):
	    	tex = tex + table4()
	    if (tables[4]):
	    	tex = tex + table5()
	    tex = tex.replace("\\begin{apidefinition}", "")
	    tex = tex.replace("\\end{apidefinition}", "")
	    text = tex[:tex.find(".SS Examples")]
	    while(text.find("\n\n") != -1):
	    	text = text.replace("\n\n", "\n")
	    while(text.find("\n ") != -1):
	    	text = text.replace("\n ", "\n")
	    text = text.replace("\\\\", "\n")
	    text = text.replace("$", "")
	    tex = text + tex[tex.find(".SS Examples"):]
	    tex = tex.replace("@", "\n\n")
	    tex = tex.replace("\n ", "\n")
	    manFile.write(tex.replace("\\n", "\\\\" + "n"))
	    manFile.close()
	    texFile.close()

if __name__== "__main__":
    main()
